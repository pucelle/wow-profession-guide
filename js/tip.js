//tooltip弹出条var win = {	//窗口的长宽,以及当前所处的滚动位置	//窗口属性的改变将自动重置win属性	size : {},	//窗口宽高	roll : {},	//滚动条位置	resize : function(){	//获取size,主流浏览器都支持		this.size.w = document.documentElement.clientWidth;		this.size.h = document.documentElement.clientHeight;	},	reroll : function(){	//获取scroll	//在有文档声明下IE6+,opera,ff可以通过documentElement获取.但是chrome和safari只认识document.body.scrollLeft/Top		this.roll.x = document.documentElement.scrollLeft || document.body.scrollLeft;		this.roll.y = document.documentElement.scrollTop  || document.body.scrollTop;	},	init : function(){	//初始化,并注册事件,调节窗口或者滚动条位置将重新获取各属性.	//IE下有一个问题,当双击调整窗口大小时,无法累加因为滚动条的出现或者消失带来的尺度缩放	//在每次重新显示tooltip时重获属性可以解决这个问题		/*window.onresize = function(){		//调整窗口可能导致滚动条位置变化			win.resize();			win.reroll();		};		window.onscroll = function(){			win.reroll();		};		this.reset();*/	},	reset : function(){	//重新获取属性		this.resize();		this.reroll();	}};var tooltip = {//鼠标移动到元素之上时的提示窗口	//minwidth	: 0,	//最小宽度	//maxwidth	: 400,	//最大宽度	//extwidth	: -4,	//元素的额外宽度	//extheight	: -4,	//元素的额外高度	dpx			: 2,		//default position x,按照tip相对em的左侧的位置:左->右,标记为0->1,2	dpy			: 0.77,	//default position y,按照tip相对em的上沿的位置:上->下,标记为0->1,2	init : function(){	//创建tooltip,为一个包含3*3区域的table		var px = ["l", "c", "r"];		var py = ["t", "c", "b"];		var tb = document.createElement("table");		tb.className = "tip";		tb.style.left = "-1000px";		for(var i=0; i<3; i++){			var tr = tb.insertRow(i);			for(var j=0; j<3; j++){				tr.insertCell(j).className = py[i]+px[j];			}		}		this.tip = tb;		this.con = tb.rows[1].cells[1];		this.args = null;	//寄存上个触发tooltip.show的头4个参数		document.getElementsByTagName("body")[0].appendChild(tb);	},	swap : function(n){	//将this.con的第一个子节点删除,插入n		while(this.con.firstChild){			this.con.removeChild(this.con.firstChild);		}		this.con.appendChild(n);	},	html : function(c){	//设定content的innerHTML	//设置innerHTML在IE下会可能导致鼠标样式短暂变为指针		this.con.innerHTML = c;	},	showByPosition : function(x, y, ew, eh, w, h, px, py){	//显示tip,6个参数依次为起点坐标,元素宽高,tip宽高	//tooltip的过渡原则(px,py的生成规则)	//所要求的应至少一个为0/2,否则tip将覆盖触发元素	//所满足的应至少一个为0/2,否则将tip紧靠页面左上	//如果其中一方要求的0/2满足,则另一方非常容易计算:不变或者过渡到02	//如果一方要求的0/2不满足(另一方要求0->1),将另一方过渡到0/2		if(typeof px==="undefined") px = this.dpx;		if(typeof py==="undefined") py = this.dpy;		var cx = [win.roll.x+w <= x, win.roll.x+win.size.w >= x+w, win.roll.x+win.size.w >= x+w+ew]; //x方向上的可容纳性		var cy = [win.roll.y+h <= y, win.roll.y+win.size.h >= y+h, win.roll.y+win.size.h >= y+h+eh]; //y方向上的可容纳性		if(px===0 || px===2){	//要求位于两边			if(!cx[px]){		//一边不满足,尝试向另一边过渡				if(cx[2-px])					px = 2-px;				else if(py <= 1){					py = Math.round(py)*2;	//将py按位置过渡到0/2					if(!cy[py])						py = 2-py;				}			}			/*if(!cx[px]){		//两边不满足,尝试使y方向向0/2过渡				if(cy[0] || cy[2]){					if(py <= 1)						py = Math.round(py)*2;	//将py按位置过渡到0/2					if(!cy[py])						py = 2-py;				}else					px = 2-px;			}*/		}else if(py===0 || py===2){			if(!cy[py]){				if(cy[2-py])					py = 2-py;				else{					px = Math.round(px)*2;					if(!cx[px])						px = 2-px;				}			}		}		//alert([px, py]);		//alert([x, y]);		if(px === 2)			x += ew;		else			x -= (1-px)*w;		if(x < win.roll.x)			x = win.roll.x;		else if(x+w > win.roll.x+win.size.w)			x = win.roll.x+win.size.w-w;		if(py === 2)			y += eh;		else			y -= (1-py)*h;		if(y < win.roll.y)			y = win.roll.y;		else if(y+h > win.roll.y+win.size.h)			y = win.roll.y+win.size.h-h;		this.tip.style.top  = y+"px";		this.tip.style.left = x+"px";	},	showbymouse : function(e, cs, cm, px, py){	//tip位置随鼠标移动,认为其对应一高宽为0的元素,额外间距取决于指针样式	//cs代表着鼠标的尺寸	//cm用于防止鼠标移入tip的保护像素,只保护左上角		e = e || event;		cs  = cs || 20;		if(typeof cm === "undefined")			cm = 0;		win.reset();		//firefox等将event作为其触发函数的第一个参数传递过来.IE中则可以直接使用event参数		//该方法可能存在这种情况:当移动鼠标时,由于tip和鼠标的间距比较短(例如小于2px),导致鼠标移入tip,触发元素的onmouseout		this.args = [win.roll.x+e.clientX-cm, win.roll.y+e.clientY-cm, cs+cm, cs+cm, px, py];		this.showByPosition(win.roll.x+e.clientX-cm, win.roll.y+e.clientY-cm, cs+cm, cs+cm, this.tip.offsetWidth, this.tip.offsetHeight, px, py);				this.tip.style.opacity = '0.9';	},	showbeside : function(e, em, px, py){	//显示在触发其的元素旁边	//em代表着触发tip的元素的margin.用于增加或者减少与tip的缓冲空间	//慎用负值的em,同样会造成鼠标移入tip		if(typeof em === "undefined")			em = 0;		win.reset();		var x = -em;		var y = -em;		//this.tar = e;		var ew = e.offsetWidth+2*em;		var eh = e.offsetHeight+2*em;		if(browser.ie){	//IE的一个奇怪的bug,使得td内部元素的offsetTop以td底部为准			for(var i=0, ep=e.parentNode; ep && i<4; i++){	//向上追溯5层寻找td,一般都足够				if(ep.nodeName.toLowerCase() === "td"){					if(ep.childNodes.length === 1)						y -= (ep.offsetHeight-e.offsetHeight) / 2;				}				ep = ep.parentNode;			}		}		while(e && e!==document.body && e!==document.body.parentNode){		//如果元素e的offsetParent不是body,添加其到body的增量.这样得到相对于body的坐标			x += e.offsetLeft;			y += e.offsetTop;			e  = e.offsetParent;		}		this.args = [x, y, ew, eh, px, py];		this.showByPosition(x, y, ew, eh, this.tip.offsetWidth, this.tip.offsetHeight, px, py);		var img = this.tip.getElementsByTagName("img")[0];		if(img && !img.complete){			this.tip.style.opacity = '0';			img.onload = this.reshow;		}		else{			this.tip.style.opacity = '0.9';		}		if(this.hideTimer){			clearTimeout(this.hideTimer);			delete this.hideTimer;		}	},	reshow : function(){	//用于在图片加载完成后,重设tip的位置,被img在onload时调用		tooltip.tip.style.opacity = '0.9';		this.onload = null;		if(tooltip.args){			tooltip.args.splice(4, 0, tooltip.tip.offsetWidth, tooltip.tip.offsetHeight);			tooltip.showByPosition.apply(tooltip, tooltip.args);		}	},	waittoload : [],	//记录了等待重置位置的img元素,在每次tooltip.hide()时重置	hide : function(){		//1000px应该足够了(取body位置做参考)		//未使用display是由于设定为none时无法取得元素高度		//未使用visibility是由于在原位置改变其内容可能会突破body,而且很占cpu		//this.args = null;		this.tip.style.opacity = '0';		this.hideTimer = setTimeout(function(){			tooltip.tip.style.left = '-9999px';			delete this.hideTimer;		}, 400);		while(this.waittoload.length > 0)			this.waittoload.pop().onload = null;	}};